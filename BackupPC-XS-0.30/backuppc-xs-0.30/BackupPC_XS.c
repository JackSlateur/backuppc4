/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of BackupPC_XS.xs. Do not edit this file, edit BackupPC_XS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "BackupPC_XS.xs"
/*
 * XS glue for perl interface to BackupPC libraries.
 *
 * Copyright (C) 2013 Craig Barratt.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, visit the http://fsf.org website.
 */


#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <backuppc.h>

typedef bpc_fileZIO_fd          *BackupPC__XS__FileZIO;
typedef bpc_refCount_info       *BackupPC__XS__PoolRefCnt;
typedef bpc_poolWrite_info      *BackupPC__XS__PoolWrite;
typedef bpc_attrib_dir          *BackupPC__XS__Attrib;
typedef bpc_attribCache_info    *BackupPC__XS__AttribCache;

#define hv_get_int(hv, key, value)       { SV** svp = hv_fetch((hv), (key), strlen(key), 0); if ( svp && *svp ) (value) = SvIV(*svp); }
#define hv_get_uint(hv, key, value)      { SV** svp = hv_fetch((hv), (key), strlen(key), 0); if ( svp && *svp ) (value) = SvUV(*svp); }
#define hv_get_str(hv, key, value, len)  { SV** svp = hv_fetch((hv), (key), strlen(key), 0); if ( svp && *svp ) (value) = SvPV(*svp, len); }

static HV* convert_file2hv(bpc_attrib_file *file, char *fileName)
{
    HV *rh;
    size_t listLen, i;

    rh = newHV();
    (void)hv_store(rh, "uid", 3,      newSVuv(file->uid), 0);
    (void)hv_store(rh, "gid", 3,      newSVuv(file->gid), 0);
    (void)hv_store(rh, "name", 4,     newSVpvn(fileName, strlen(fileName)), 0);
    (void)hv_store(rh, "type", 4,     newSVuv(file->type), 0);
    (void)hv_store(rh, "mode", 4,     newSVuv(file->mode), 0);
    (void)hv_store(rh, "size", 4,     newSVuv(file->size), 0);
    (void)hv_store(rh, "mtime", 5,    newSVuv(file->mtime), 0);
    (void)hv_store(rh, "inode", 5,    newSVuv(file->inode), 0);
    (void)hv_store(rh, "nlinks", 6,   newSVuv(file->nlinks), 0);
    (void)hv_store(rh, "digest", 6,   newSVpvn((char*)file->digest.digest, file->digest.len), 0);
    (void)hv_store(rh, "compress", 8, newSVuv(file->compress), 0);

    if ( (listLen = bpc_attrib_xattrList(file, NULL, 0, 0)) > 0 ) {
        char *keys = malloc(listLen), *p;

        if ( keys && bpc_attrib_xattrList(file, keys, listLen, 0) > 0 ) {
            HV *rhAttr = newHV();
            for ( i = 0, p = keys ; i < listLen ; ) {
                int len = strlen(p);
                /*
                 * xattr keys include the \0 terminating byte in the length, so add 1 here,
                 * and subtract 1 in the hv_store() below.
                 */
                bpc_attrib_xattr *xattr = bpc_attrib_xattrGet(file, p, len + 1, 0);
                p += len + 1;
                i += len + 1;
                if ( !xattr ) continue;
                (void)hv_store(rhAttr, xattr->key.key, xattr->key.keyLen - 1, newSVpvn(xattr->value, xattr->valueLen), 0);
            }
            (void)hv_store(rh, "xattr", 5, newRV_noinc((SV*)rhAttr), 0);
        }
        if ( keys ) free(keys);
    }
    return rh;
}

static void convert_hv2file(HV *hv, bpc_attrib_file *file)
{
    char *digestStr = "";
    STRLEN digestLen = 0;
    SV** svp;

    hv_get_uint(hv, "uid", file->uid);
    hv_get_uint(hv, "gid", file->gid);
    hv_get_uint(hv, "type", file->type);
    hv_get_uint(hv, "mode", file->mode);
    hv_get_uint(hv, "size", file->size);
    hv_get_uint(hv, "mtime", file->mtime);
    hv_get_uint(hv, "inode", file->inode);
    hv_get_uint(hv, "nlinks", file->nlinks);
    hv_get_uint(hv, "compress", file->compress);
    hv_get_str(hv,  "digest", digestStr, digestLen);
    if ( 0 < digestLen && digestLen <= sizeof(file->digest.digest) ) {
        memcpy(file->digest.digest, digestStr, digestLen);
        file->digest.len = digestLen;
    } else {
        file->digest.len = 0;
    }
    if ( (svp = hv_fetch(hv, "xattr", 5, 0)) && *svp ) {
        HE *he;
        HV *hvXattr = (HV*)SvRV(*svp);
        /*
         * clear out the old xattrs, and copy in the new
         */
        bpc_attrib_xattrDeleteAll(file);
        hv_iterinit(hvXattr);
        while ( (he = hv_iternext(hvXattr)) ) {
            I32 keyLen;
            STRLEN valueLen;
            char *key = hv_iterkey(he, &keyLen), *value;
            SV *valSV = hv_iterval(hvXattr, he);

            value = SvPV(valSV, valueLen);
            bpc_attrib_xattrSetValue(file, key, keyLen, value, valueLen);
        }
    }
}

#line 133 "BackupPC_XS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 275 "BackupPC_XS.c"

XS_EUPXS(XS_BackupPC__XS__FileZIO_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_open)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "fileName, writeFile, compressLevel");
    {
	char *	fileName = (char *)SvPV_nolen(ST(0))
;
	int	writeFile = (int)SvIV(ST(1))
;
	int	compressLevel = (int)SvIV(ST(2))
;
	BackupPC__XS__FileZIO	RETVAL;
#line 133 "BackupPC_XS.xs"
    {
        RETVAL = calloc(1, sizeof(bpc_fileZIO_fd));
        if ( bpc_fileZIO_open(RETVAL, fileName, writeFile, compressLevel) < 0 ) {
            free(RETVAL);
            XSRETURN_UNDEF;
        }
    }
#line 299 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::FileZIO", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_fdopen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_fdopen)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "stream, writeFile, compressLevel");
    {
	FILE *	stream = PerlIO_findFILE(IoIFP(sv_2io(ST(0))))
;
	int	writeFile = (int)SvIV(ST(1))
;
	int	compressLevel = (int)SvIV(ST(2))
;
	BackupPC__XS__FileZIO	RETVAL;
#line 149 "BackupPC_XS.xs"
    {
        RETVAL = calloc(1, sizeof(bpc_fileZIO_fd));
        if ( bpc_fileZIO_fdopen(RETVAL, stream, writeFile, compressLevel) < 0 ) {
            free(RETVAL);
            XSRETURN_UNDEF;
        }
    }
#line 329 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::FileZIO", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    {
	BackupPC__XS__FileZIO	fd;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"BackupPC::XS::FileZIO::DESTROY",
			"fd")
;
#line 163 "BackupPC_XS.xs"
        bpc_fileZIO_close(fd);
        free(fd);
#line 358 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    {
	BackupPC__XS__FileZIO	fd;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::close",
			"fd", "BackupPC::XS::FileZIO")
;
#line 170 "BackupPC_XS.xs"
    {
        bpc_fileZIO_close(fd);
    }
#line 386 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_rewind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_rewind)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    {
	BackupPC__XS__FileZIO	fd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::rewind",
			"fd", "BackupPC::XS::FileZIO")
;
#line 178 "BackupPC_XS.xs"
    {
        RETVAL = bpc_fileZIO_rewind(fd);
    }
#line 416 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fd, data");
    {
	BackupPC__XS__FileZIO	fd;
	SV *	data = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::write",
			"fd", "BackupPC::XS::FileZIO")
;
#line 189 "BackupPC_XS.xs"
    {
        char *str;
        STRLEN len;

        if ( SvROK(data) ) {
            str = SvPV(SvRV(data), len);
            RETVAL = bpc_fileZIO_write(fd, (unsigned char*)str, len);
        } else {
            RETVAL = -1;
        }
    }
#line 457 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_read)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "fd, data, len");
    {
	BackupPC__XS__FileZIO	fd;
	SV *	data = ST(1)
;
	STRLEN	len = (STRLEN)SvUV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::read",
			"fd", "BackupPC::XS::FileZIO")
;
#line 209 "BackupPC_XS.xs"
    {
        char *str;
        SV *d;
        STRLEN dLen;

        if ( SvROK(data) ) {
            d = SvRV(data);
            if (! SvOK(d))
                sv_setpvs(d, "");
            SvGROW(d, len);
            str = SvPV(d, dLen);
            RETVAL = bpc_fileZIO_read(fd, (unsigned char*)str, len);
            SvCUR_set(d, RETVAL);
        } else {
            RETVAL = -1;
        }
    }
#line 506 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_readLine); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_readLine)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fd");
    {
	BackupPC__XS__FileZIO	fd;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::readLine",
			"fd", "BackupPC::XS::FileZIO")
;
#line 233 "BackupPC_XS.xs"
    {
        char *str;
        size_t strLen;
        if ( bpc_fileZIO_readLine(fd, &str, &strLen) || !str ) XSRETURN_UNDEF;
        RETVAL = newSVpvn(str, strLen);
    }
#line 539 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__FileZIO_writeTeeStderr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__FileZIO_writeTeeStderr)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fd, tee");
    {
	BackupPC__XS__FileZIO	fd;
	int	tee = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::FileZIO")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fd = INT2PTR(BackupPC__XS__FileZIO,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::FileZIO::writeTeeStderr",
			"fd", "BackupPC::XS::FileZIO")
;
#line 247 "BackupPC_XS.xs"
        bpc_fileZIO_writeTeeStderr(fd, tee);
#line 569 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "entryCnt = 65536");
    {
	int	entryCnt;
	BackupPC__XS__PoolRefCnt	RETVAL;

	if (items < 1)
	    entryCnt = 65536;
	else {
	    entryCnt = (int)SvIV(ST(0))
;
	}
#line 255 "BackupPC_XS.xs"
    {
        RETVAL = calloc(1, sizeof(bpc_refCount_info));
        bpc_poolRefInit((bpc_refCount_info*)RETVAL, entryCnt);
    }
#line 596 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::PoolRefCnt", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "info");
    {
	BackupPC__XS__PoolRefCnt	info;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"BackupPC::XS::PoolRefCnt::DESTROY",
			"info")
;
#line 266 "BackupPC_XS.xs"
    {
        bpc_poolRefDestroy(info);
        free(info);
    }
#line 627 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, d");
    {
	BackupPC__XS__PoolRefCnt	info;
	SV *	d = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::get",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 276 "BackupPC_XS.xs"
    {
        bpc_digest digest;
        char *str;
        STRLEN len;
        int count;

        if ( !SvPOK(d) ) {
            XSRETURN_UNDEF;
        }
        str = SvPV(d, len);
        if ( 0 < len && len < sizeof(digest.digest) ) {
            memcpy(digest.digest, str, len);
            digest.len = len;
            if ( bpc_poolRefGet(info, &digest, &count) ) XSRETURN_UNDEF;
            RETVAL = count;
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 675 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "info, d, count");
    {
	BackupPC__XS__PoolRefCnt	info;
	SV *	d = ST(1)
;
	int	count = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::set",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 304 "BackupPC_XS.xs"
    {
        bpc_digest digest;
        char *str;
        STRLEN len;

        if ( !SvPOK(d) ) {
            XSRETURN_UNDEF;
        }
        str = SvPV(d, len);
        if ( 0 < len && len < sizeof(digest.digest) ) {
            memcpy(digest.digest, str, len);
            digest.len = len;
            bpc_poolRefSet(info, &digest, count);
            RETVAL = count;
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 725 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_delete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, d");
    {
	BackupPC__XS__PoolRefCnt	info;
	SV *	d = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::delete",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 330 "BackupPC_XS.xs"
    {
        bpc_digest digest;
        char *str;
        STRLEN len;

        if ( !SvPOK(d) ) {
            XSRETURN_UNDEF;
        }
        str = SvPV(d, len);
        if ( 0 < len && len < sizeof(digest.digest) ) {
            memcpy(digest.digest, str, len);
            digest.len = len;
            if ( bpc_poolRefDelete(info, &digest) ) XSRETURN_UNDEF;
            RETVAL = 1;
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 773 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_incr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_incr)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "info, d, delta");
    {
	BackupPC__XS__PoolRefCnt	info;
	SV *	d = ST(1)
;
	int	delta = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::incr",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 357 "BackupPC_XS.xs"
    {
        bpc_digest digest;
        char *str;
        STRLEN len;

        if ( !SvPOK(d) ) {
            XSRETURN_UNDEF;
        }
        str = SvPV(d, len);
        if ( 0 < len && len < sizeof(digest.digest) ) {
            memcpy(digest.digest, str, len);
            digest.len = len;
            RETVAL = bpc_poolRefIncr(info, &digest, delta);
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 822 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_iterate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_iterate)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BackupPC__XS__PoolRefCnt	info;
	unsigned int	idx = (unsigned int)SvUV(ST(1))
;
#line 382 "BackupPC_XS.xs"
        bpc_digest digest;
        int count;
#line 844 "BackupPC_XS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::iterate",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 385 "BackupPC_XS.xs"
    {
        if ( !bpc_poolRefIterate(info, &digest, &count, &idx) ) {
            EXTEND(SP, 3);
            PUSHs(sv_2mortal(newSVpvn((char*)digest.digest, digest.len)));
            PUSHs(sv_2mortal(newSViv(count)));
            PUSHs(sv_2mortal(newSViv(idx)));
        }
    }
#line 864 "BackupPC_XS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_read)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, fileName");
    {
	BackupPC__XS__PoolRefCnt	info;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::read",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 399 "BackupPC_XS.xs"
        RETVAL = bpc_poolRefFileRead(info, fileName);
#line 895 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, fileName");
    {
	BackupPC__XS__PoolRefCnt	info;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::write",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 408 "BackupPC_XS.xs"
        RETVAL = bpc_poolRefFileWrite(info, fileName);
#line 926 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_print)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "info");
    {
	BackupPC__XS__PoolRefCnt	info;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolRefCnt")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolRefCnt,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolRefCnt::print",
			"info", "BackupPC::XS::PoolRefCnt")
;
#line 416 "BackupPC_XS.xs"
        bpc_poolRefCountPrint(info);
#line 953 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaFileInit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaFileInit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hostDir");
    {
	char *	hostDir = (char *)SvPV_nolen(ST(0))
;
#line 422 "BackupPC_XS.xs"
        bpc_poolRefDeltaFileInit(hostDir);
#line 970 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaFileFlush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaFileFlush)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	unsigned int	RETVAL;
	dXSTARG;
#line 427 "BackupPC_XS.xs"
        RETVAL = bpc_poolRefDeltaFileFlush();
#line 987 "BackupPC_XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaUpdate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaUpdate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "compress, d, count");
    {
	int	compress = (int)SvIV(ST(0))
;
	SV *	d = ST(1)
;
	int	count = (int)SvIV(ST(2))
;
#line 437 "BackupPC_XS.xs"
    {
        bpc_digest digest;
        char *str;
        STRLEN len;

        if ( SvPOK(d) ) {
            str = SvPV(d, len);
            if ( 0 < len && len < sizeof(digest.digest) ) {
                memcpy(digest.digest, str, len);
                digest.len = len;
                bpc_poolRefDeltaUpdate(compress, &digest, count);
            }
        }
    }
#line 1022 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaPrint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolRefCnt_DeltaPrint)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 455 "BackupPC_XS.xs"
        bpc_poolRefDeltaPrint();
#line 1037 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolWrite_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolWrite_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "compressLevel, d = NULL");
    {
	int	compressLevel = (int)SvIV(ST(0))
;
	SV *	d;
	BackupPC__XS__PoolWrite	RETVAL;

	if (items < 2)
	    d = NULL;
	else {
	    d = ST(1)
;
	}
#line 464 "BackupPC_XS.xs"
    {
        int ret = 0;

        RETVAL = calloc(1, sizeof(bpc_poolWrite_info));
        if ( d && SvPOK(d) ) {
            bpc_digest digest;
            char *str;
            STRLEN len;

            str = SvPV(d, len);
            if ( 0 < len && len < sizeof(digest.digest) ) {
                memcpy(digest.digest, str, len);
                digest.len = len;
                ret = bpc_poolWrite_open(RETVAL, compressLevel, &digest);
            } else {
                ret = bpc_poolWrite_open(RETVAL, compressLevel, NULL);
            }
        } else {
            ret = bpc_poolWrite_open(RETVAL, compressLevel, NULL);
        }
        if ( ret ) {
            free(RETVAL);
            RETVAL = NULL;
        }
    }
#line 1087 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::PoolWrite", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolWrite_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolWrite_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "info");
    {
	BackupPC__XS__PoolWrite	info;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolWrite,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"BackupPC::XS::PoolWrite::DESTROY",
			"info")
;
#line 496 "BackupPC_XS.xs"
    {
        bpc_poolWrite_cleanup(info);
        free(info);
    }
#line 1118 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__PoolWrite_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolWrite_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "info");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BackupPC__XS__PoolWrite	info;
#line 505 "BackupPC_XS.xs"
        int match;
        bpc_digest digest;
        off_t poolFileSize;
        int errorCnt;

#line 1140 "BackupPC_XS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolWrite")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolWrite,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolWrite::close",
			"info", "BackupPC::XS::PoolWrite")
;
#line 511 "BackupPC_XS.xs"
    {
        bpc_poolWrite_close(info, &match, &digest, &poolFileSize, &errorCnt);
        EXTEND(SP, 4);
        PUSHs(sv_2mortal(newSViv(match)));
        PUSHs(sv_2mortal(newSVpvn((char*)digest.digest, digest.len)));
        PUSHs(sv_2mortal(newSViv(poolFileSize)));
        PUSHs(sv_2mortal(newSViv(errorCnt)));
    }
#line 1160 "BackupPC_XS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_BackupPC__XS__PoolWrite_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolWrite_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "info, data");
    {
	BackupPC__XS__PoolWrite	info;
	SV *	data = ST(1)
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolWrite")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolWrite,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolWrite::write",
			"info", "BackupPC::XS::PoolWrite")
;
#line 525 "BackupPC_XS.xs"
    {
        char *str;
        STRLEN len;

        if ( SvROK(data) ) {
            str = SvPV(SvRV(data), len);
            RETVAL = bpc_poolWrite_write(info, (unsigned char*)str, len);
        } else {
            RETVAL = -1;
        }
    }
#line 1201 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__PoolWrite_addToPool); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__PoolWrite_addToPool)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "info, fileName, v3PoolFile");
    {
	BackupPC__XS__PoolWrite	info;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	int	v3PoolFile = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::PoolWrite")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    info = INT2PTR(BackupPC__XS__PoolWrite,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::PoolWrite::addToPool",
			"info", "BackupPC::XS::PoolWrite")
;
#line 545 "BackupPC_XS.xs"
        bpc_poolWrite_addToPool(info, fileName, v3PoolFile);
#line 1232 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__Attrib_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "compressLevel");
    {
	int	compressLevel = (int)SvIV(ST(0))
;
	BackupPC__XS__Attrib	RETVAL;
#line 553 "BackupPC_XS.xs"
    {
        RETVAL = calloc(1, sizeof(bpc_attrib_dir));
        bpc_attrib_dirInit(RETVAL, compressLevel);
    }
#line 1253 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::Attrib", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dir");
    {
	BackupPC__XS__Attrib	dir;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"BackupPC::XS::Attrib::DESTROY",
			"dir")
;
#line 564 "BackupPC_XS.xs"
    {
        bpc_attrib_dirDestroy(dir);
        free(dir);
    }
#line 1284 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__Attrib_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_get)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dir, fileName = NULL");
    {
	BackupPC__XS__Attrib	dir;
	char *	fileName;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::get",
			"dir", "BackupPC::XS::Attrib")
;

	if (items < 2)
	    fileName = NULL;
	else {
	    fileName = (char *)SvPV_nolen(ST(1))
;
	}
#line 574 "BackupPC_XS.xs"
    {
        if ( fileName ) {
            bpc_attrib_file *file = bpc_attrib_fileGet(dir, fileName, 0);
            if ( !file ) XSRETURN_UNDEF;
            RETVAL = newRV_noinc((SV*)convert_file2hv(file, file->name));
        } else {
            ssize_t entrySize, i;

            RETVAL = NULL;
            if ( (entrySize = bpc_attrib_getEntries(dir, NULL, 0)) > 0 ) {
                char *entries = malloc(entrySize), *p;

                if ( entries && bpc_attrib_getEntries(dir, entries, entrySize) > 0 ) {
                    HV *rh = newHV();
                    for ( i = 0, p = entries ; i < entrySize ; ) {
                        int len = strlen(p);
                        bpc_attrib_file *file;

                        file = bpc_attrib_fileGet(dir, p, 0);
                        p += len + 1;
                        i += len + 1;
                        if ( !file ) continue;
                        (void)hv_store(rh, file->name, strlen(file->name), newRV_noinc((SV*)convert_file2hv(file, file->name)), 0);
                    }
                    RETVAL = newRV_noinc((SV*)rh);
                }
                if ( entries ) free(entries);
            }
            if ( !RETVAL ) XSRETURN_UNDEF;
        }
    }
#line 1349 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dir, fileName, hv");
    {
	BackupPC__XS__Attrib	dir;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	HV *	hv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::set",
			"dir", "BackupPC::XS::Attrib")
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    hv = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"BackupPC::XS::Attrib::set",
				"hv");
		}
	} STMT_END
;
#line 614 "BackupPC_XS.xs"
    {
        bpc_attrib_file *file = bpc_attrib_fileGet(dir, fileName, 0);

        RETVAL = file ? 1 : 0;
        if ( !file ) {
            file = bpc_attrib_fileGet(dir, fileName, 1);
            bpc_attrib_fileInit(file, fileName, 0);
        }
        convert_hv2file(hv, file);
    }
#line 1405 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_digest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_digest)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dir");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	BackupPC__XS__Attrib	dir;
#line 631 "BackupPC_XS.xs"
#line 1423 "BackupPC_XS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::digest",
			"dir", "BackupPC::XS::Attrib")
;
#line 632 "BackupPC_XS.xs"
    {
        bpc_digest *digest = bpc_attrib_dirDigestGet(dir);
        if ( digest && digest->len > 0 ) {
            EXTEND(SP, 1);
            PUSHs(sv_2mortal(newSVpvn((char*)digest->digest, digest->len)));
        }
    }
#line 1442 "BackupPC_XS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_BackupPC__XS__Attrib_errStr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_errStr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "void");
    {
	char *	RETVAL;
	dXSTARG;
#line 643 "BackupPC_XS.xs"
        RETVAL = "TODO";
#line 1460 "BackupPC_XS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dir");
    {
	BackupPC__XS__Attrib	dir;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::count",
			"dir", "BackupPC::XS::Attrib")
;
#line 651 "BackupPC_XS.xs"
        RETVAL = bpc_attrib_fileCount(dir);
#line 1489 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_delete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dir, fileName");
    {
	BackupPC__XS__Attrib	dir;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::delete",
			"dir", "BackupPC::XS::Attrib")
;
#line 660 "BackupPC_XS.xs"
        bpc_attrib_fileDeleteName(dir, fileName);
#line 1518 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__Attrib_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_read)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dir, dirPath, attribFileName = \"attrib\"");
    {
	BackupPC__XS__Attrib	dir;
	char *	dirPath = (char *)SvPV_nolen(ST(1))
;
	char *	attribFileName;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::read",
			"dir", "BackupPC::XS::Attrib")
;

	if (items < 3)
	    attribFileName = "attrib";
	else {
	    attribFileName = (char *)SvPV_nolen(ST(2))
;
	}
#line 668 "BackupPC_XS.xs"
        if ( !*dirPath ) dirPath = NULL;
        RETVAL = !bpc_attrib_dirRead(dir, dirPath, attribFileName, 0);
#line 1557 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_write)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dir, dirPath, attribFileName, d = NULL");
    {
	BackupPC__XS__Attrib	dir;
	char *	dirPath = (char *)SvPV_nolen(ST(1))
;
	char *	attribFileName = (char *)SvPV_nolen(ST(2))
;
	SV *	d;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::Attrib")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dir = INT2PTR(BackupPC__XS__Attrib,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::Attrib::write",
			"dir", "BackupPC::XS::Attrib")
;

	if (items < 4)
	    d = NULL;
	else {
	    d = ST(3)
;
	}
#line 680 "BackupPC_XS.xs"
        if ( !*dirPath ) dirPath = NULL;
        if ( d && SvPOK(d) ) {
            bpc_digest digest;
            char *str;
            STRLEN len;

            str = SvPV(d, len);
            if ( 0 < len && len < sizeof(digest.digest) ) {
                memcpy(digest.digest, str, len);
                digest.len = len;
                RETVAL = !bpc_attrib_dirWrite(dir, dirPath, attribFileName, &digest);
            } else {
                RETVAL = !bpc_attrib_dirWrite(dir, dirPath, attribFileName, NULL);
            }
        } else {
            RETVAL = !bpc_attrib_dirWrite(dir, dirPath, attribFileName, NULL);
        }
#line 1614 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Attrib_fileType2Text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Attrib_fileType2Text)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "type");
    {
	int	type = (int)SvIV(ST(0))
;
	char *	RETVAL;
	dXSTARG;
#line 704 "BackupPC_XS.xs"
        RETVAL = bpc_attrib_fileType2Text(type);
#line 1634 "BackupPC_XS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "host, backupNum, shareNameUM, compress");
    {
	char *	host = (char *)SvPV_nolen(ST(0))
;
	int	backupNum = (int)SvIV(ST(1))
;
	char *	shareNameUM = (char *)SvPV_nolen(ST(2))
;
	int	compress = (int)SvIV(ST(3))
;
	BackupPC__XS__AttribCache	RETVAL;
#line 717 "BackupPC_XS.xs"
    {
        RETVAL = calloc(1, sizeof(bpc_attribCache_info));
        bpc_attribCache_init(RETVAL, host, backupNum, shareNameUM, compress);
    }
#line 1662 "BackupPC_XS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "BackupPC::XS::AttribCache", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ac");
    {
	BackupPC__XS__AttribCache	ac;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"BackupPC::XS::AttribCache::DESTROY",
			"ac")
;
#line 728 "BackupPC_XS.xs"
    {
        bpc_attribCache_destroy(ac);
        free(ac);
    }
#line 1693 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_get)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "ac, fileName, allocateIfMissing = 0, dontReadInode = 0");
    {
	BackupPC__XS__AttribCache	ac;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	int	allocateIfMissing;
	int	dontReadInode;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::get",
			"ac", "BackupPC::XS::AttribCache")
;

	if (items < 3)
	    allocateIfMissing = 0;
	else {
	    allocateIfMissing = (int)SvIV(ST(2))
;
	}

	if (items < 4)
	    dontReadInode = 0;
	else {
	    dontReadInode = (int)SvIV(ST(3))
;
	}
#line 740 "BackupPC_XS.xs"
    {
        bpc_attrib_file *file = bpc_attribCache_getFile(ac, fileName, allocateIfMissing, dontReadInode);

        if ( !file ) XSRETURN_UNDEF;

        RETVAL = newRV_noinc((SV*)convert_file2hv(file, file->name));
    }
#line 1744 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_set)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "ac, fileName, hv, dontOverwriteInode = 0");
    {
	BackupPC__XS__AttribCache	ac;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	HV *	hv;
	int	dontOverwriteInode;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::set",
			"ac", "BackupPC::XS::AttribCache")
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    hv = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"BackupPC::XS::AttribCache::set",
				"hv");
		}
	} STMT_END
;

	if (items < 4)
	    dontOverwriteInode = 0;
	else {
	    dontOverwriteInode = (int)SvIV(ST(3))
;
	}
#line 757 "BackupPC_XS.xs"
    {
        bpc_attrib_file *file = bpc_attribCache_getFile(ac, fileName, 1, 0);

        convert_hv2file(hv, file);
        RETVAL = bpc_attribCache_setFile(ac, fileName, file, dontOverwriteInode);
    }
#line 1804 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_delete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ac, fileName");
    {
	BackupPC__XS__AttribCache	ac;
	char *	fileName = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::delete",
			"ac", "BackupPC::XS::AttribCache")
;
#line 771 "BackupPC_XS.xs"
        RETVAL = bpc_attribCache_deleteFile(ac, fileName);
#line 1835 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_getInode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_getInode)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ac, inode, allocateIfMissing = 0");
    {
	BackupPC__XS__AttribCache	ac;
	unsigned long	inode = (unsigned long)SvUV(ST(1))
;
	int	allocateIfMissing;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::getInode",
			"ac", "BackupPC::XS::AttribCache")
;

	if (items < 3)
	    allocateIfMissing = 0;
	else {
	    allocateIfMissing = (int)SvIV(ST(2))
;
	}
#line 781 "BackupPC_XS.xs"
    {
        bpc_attrib_file *file = bpc_attribCache_getInode(ac, inode, allocateIfMissing);

        if ( !file ) XSRETURN_UNDEF;

        RETVAL = newRV_noinc((SV*)convert_file2hv(file, file->name));
    }
#line 1879 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_setInode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_setInode)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "ac, inode, hv");
    {
	BackupPC__XS__AttribCache	ac;
	unsigned long	inode = (unsigned long)SvUV(ST(1))
;
	HV *	hv;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::setInode",
			"ac", "BackupPC::XS::AttribCache")
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    hv = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"BackupPC::XS::AttribCache::setInode",
				"hv");
		}
	} STMT_END
;
#line 797 "BackupPC_XS.xs"
    {
        bpc_attrib_file *file = bpc_attribCache_getInode(ac, inode, 1);

        convert_hv2file(hv, file);
        RETVAL = bpc_attribCache_setInode(ac, inode, file);
    }
#line 1931 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_deleteInode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_deleteInode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ac, inode");
    {
	BackupPC__XS__AttribCache	ac;
	unsigned long	inode = (unsigned long)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::deleteInode",
			"ac", "BackupPC::XS::AttribCache")
;
#line 811 "BackupPC_XS.xs"
        RETVAL = bpc_attribCache_deleteInode(ac, inode);
#line 1962 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ac, path");
    {
	BackupPC__XS__AttribCache	ac;
	char *	path = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::count",
			"ac", "BackupPC::XS::AttribCache")
;
#line 820 "BackupPC_XS.xs"
        RETVAL = bpc_attribCache_getDirEntryCnt(ac, path);
#line 1993 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_getAll); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_getAll)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ac, path, dontReadInode = 0");
    {
	BackupPC__XS__AttribCache	ac;
	char *	path = (char *)SvPV_nolen(ST(1))
;
	int	dontReadInode;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::getAll",
			"ac", "BackupPC::XS::AttribCache")
;

	if (items < 3)
	    dontReadInode = 0;
	else {
	    dontReadInode = (int)SvIV(ST(2))
;
	}
#line 830 "BackupPC_XS.xs"
    {
        ssize_t entrySize, i;
        char pathCopy[BPC_MAXPATHLEN];

        snprintf(pathCopy, sizeof(pathCopy), "%s", path);
        RETVAL = NULL;
        if ( (entrySize = bpc_attribCache_getDirEntries(ac, pathCopy, NULL, 0)) > 0 ) {
            char *entries = malloc(entrySize), *p;

            if ( entries && bpc_attribCache_getDirEntries(ac, pathCopy, entries, entrySize) > 0 ) {
                HV *rh = newHV();
                for ( i = 0, p = entries ; i < entrySize ; ) {
                    int len = strlen(p);
                    char *fileNameSave = p;
                    char filePath[BPC_MAXPATHLEN];
                    bpc_attrib_file *file;

                    snprintf(filePath, sizeof(filePath), "%s/%s", path, p);
                    file = bpc_attribCache_getFile(ac, filePath, 0, dontReadInode);
                    p += len + 1 + sizeof(ino_t);
                    i += len + 1 + sizeof(ino_t);
                    if ( !file ) continue;
                    /* printf("Storing file name %s for path %s\n", fileNameSave, path); */
                    (void)hv_store(rh, fileNameSave, strlen(fileNameSave), newRV_noinc((SV*)convert_file2hv(file, fileNameSave)), 0);
                }
                RETVAL = newRV_noinc((SV*)rh);
            }
            if ( entries ) free(entries);
        }
        if ( !RETVAL ) XSRETURN_UNDEF;
    }
#line 2061 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_flush)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "ac, all = 1, path = NULL");
    {
	BackupPC__XS__AttribCache	ac;
	int	all;
	char *	path;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::flush",
			"ac", "BackupPC::XS::AttribCache")
;

	if (items < 2)
	    all = 1;
	else {
	    all = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    path = NULL;
	else {
	    path = (char *)SvPV_nolen(ST(2))
;
	}
#line 870 "BackupPC_XS.xs"
        bpc_attribCache_flush(ac, all, path);
#line 2105 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__AttribCache_getFullMangledPath); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__AttribCache_getFullMangledPath)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ac, dirName");
    {
	BackupPC__XS__AttribCache	ac;
	char *	dirName = (char *)SvPV_nolen(ST(1))
;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "BackupPC::XS::AttribCache")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    ac = INT2PTR(BackupPC__XS__AttribCache,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"BackupPC::XS::AttribCache::getFullMangledPath",
			"ac", "BackupPC::XS::AttribCache")
;
#line 877 "BackupPC_XS.xs"
    {
        char path[MAXPATHLEN];
        bpc_attribCache_getFullMangledPath(ac, path, dirName, -1);
        RETVAL = newSVpvn(path, strlen(path));
    }
#line 2138 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_path_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_path_create)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	char *	path = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 891 "BackupPC_XS.xs"
        RETVAL = bpc_path_create(path);
#line 2159 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_path_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_path_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, compress");
    {
	char *	path = (char *)SvPV_nolen(ST(0))
;
	int	compress = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 900 "BackupPC_XS.xs"
        RETVAL = bpc_path_remove(path, compress);
#line 2181 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_refCountAll); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_refCountAll)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "path, compress");
    {
	char *	path = (char *)SvPV_nolen(ST(0))
;
	int	compress = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 909 "BackupPC_XS.xs"
        RETVAL = bpc_path_refCountAll(path, compress);
#line 2203 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_lockRangeFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_lockRangeFd)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "fd, offset, len, block");
    {
	int	fd = (int)SvIV(ST(0))
;
	unsigned int	offset = (unsigned int)SvUV(ST(1))
;
	unsigned int	len = (unsigned int)SvUV(ST(2))
;
	int	block = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;
#line 920 "BackupPC_XS.xs"
        RETVAL = bpc_lockRangeFd(fd, offset, len, block);
#line 2229 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_unlockRangeFd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_unlockRangeFd)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "fd, offset, len");
    {
	int	fd = (int)SvIV(ST(0))
;
	unsigned int	offset = (unsigned int)SvUV(ST(1))
;
	unsigned int	len = (unsigned int)SvUV(ST(2))
;
	int	RETVAL;
	dXSTARG;
#line 930 "BackupPC_XS.xs"
        RETVAL = bpc_unlockRangeFd(fd, offset, len);
#line 2253 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_lockRangeFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_lockRangeFile)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "lockFile, offset, len, block");
    {
	char *	lockFile = (char *)SvPV_nolen(ST(0))
;
	unsigned int	offset = (unsigned int)SvUV(ST(1))
;
	unsigned int	len = (unsigned int)SvUV(ST(2))
;
	int	block = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;
#line 941 "BackupPC_XS.xs"
        RETVAL = bpc_lockRangeFile(lockFile, offset, len, block);
#line 2279 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__DirOps_unlockRangeFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__DirOps_unlockRangeFile)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lockFd");
    {
	int	lockFd = (int)SvIV(ST(0))
;
#line 949 "BackupPC_XS.xs"
        bpc_unlockRangeFile(lockFd);
#line 2297 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__Lib_ConfInit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Lib_ConfInit)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "topDir, hardLinkMax, poolV3Enabled, logLevel = 0");
    {
	char *	topDir = (char *)SvPV_nolen(ST(0))
;
	int	hardLinkMax = (int)SvIV(ST(1))
;
	int	poolV3Enabled = (int)SvIV(ST(2))
;
	int	logLevel;

	if (items < 4)
	    logLevel = 0;
	else {
	    logLevel = (int)SvIV(ST(3))
;
	}
#line 960 "BackupPC_XS.xs"
        bpc_lib_conf_init(topDir, hardLinkMax, poolV3Enabled, logLevel);
#line 2326 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_BackupPC__XS__Lib_logMsgGet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Lib_logMsgGet)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 965 "BackupPC_XS.xs"
    {
        char *mesg, *p;
        size_t mesgLen, i;
        AV *ra;

        RETVAL = NULL;
        bpc_logMsgGet(&mesg, &mesgLen);
        if ( mesgLen == 0 ) XSRETURN_UNDEF;

        ra = newAV();
        for ( i = 0, p = mesg ; i < mesgLen ; ) {
            int len = strlen(p);

            av_push(ra, newSVpvn(p, len));
            p += len + 1;
            i += len + 1;
        }
        RETVAL = newRV_noinc((SV*)ra);
    }
#line 2360 "BackupPC_XS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Lib_logErrorCntGet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Lib_logErrorCntGet)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 990 "BackupPC_XS.xs"
    {
        unsigned long errorCnt;
        bpc_logMsgErrorCntGet(&errorCnt);
        RETVAL = errorCnt;
    }
#line 2383 "BackupPC_XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_BackupPC__XS__Lib_logLevelSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_BackupPC__XS__Lib_logLevelSet)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "logLevel");
    {
	int	logLevel = (int)SvIV(ST(0))
;
#line 1002 "BackupPC_XS.xs"
        bpc_lib_setLogLevel(logLevel);
#line 2401 "BackupPC_XS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_BackupPC__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_BackupPC__XS)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("BackupPC::XS::FileZIO::open", XS_BackupPC__XS__FileZIO_open, file);
        newXS("BackupPC::XS::FileZIO::fdopen", XS_BackupPC__XS__FileZIO_fdopen, file);
        newXS("BackupPC::XS::FileZIO::DESTROY", XS_BackupPC__XS__FileZIO_DESTROY, file);
        newXS("BackupPC::XS::FileZIO::close", XS_BackupPC__XS__FileZIO_close, file);
        newXS("BackupPC::XS::FileZIO::rewind", XS_BackupPC__XS__FileZIO_rewind, file);
        newXS("BackupPC::XS::FileZIO::write", XS_BackupPC__XS__FileZIO_write, file);
        newXS("BackupPC::XS::FileZIO::read", XS_BackupPC__XS__FileZIO_read, file);
        newXS("BackupPC::XS::FileZIO::readLine", XS_BackupPC__XS__FileZIO_readLine, file);
        newXS("BackupPC::XS::FileZIO::writeTeeStderr", XS_BackupPC__XS__FileZIO_writeTeeStderr, file);
        newXS("BackupPC::XS::PoolRefCnt::new", XS_BackupPC__XS__PoolRefCnt_new, file);
        newXS("BackupPC::XS::PoolRefCnt::DESTROY", XS_BackupPC__XS__PoolRefCnt_DESTROY, file);
        newXS("BackupPC::XS::PoolRefCnt::get", XS_BackupPC__XS__PoolRefCnt_get, file);
        newXS("BackupPC::XS::PoolRefCnt::set", XS_BackupPC__XS__PoolRefCnt_set, file);
        newXS("BackupPC::XS::PoolRefCnt::delete", XS_BackupPC__XS__PoolRefCnt_delete, file);
        newXS("BackupPC::XS::PoolRefCnt::incr", XS_BackupPC__XS__PoolRefCnt_incr, file);
        newXS("BackupPC::XS::PoolRefCnt::iterate", XS_BackupPC__XS__PoolRefCnt_iterate, file);
        newXS("BackupPC::XS::PoolRefCnt::read", XS_BackupPC__XS__PoolRefCnt_read, file);
        newXS("BackupPC::XS::PoolRefCnt::write", XS_BackupPC__XS__PoolRefCnt_write, file);
        newXS("BackupPC::XS::PoolRefCnt::print", XS_BackupPC__XS__PoolRefCnt_print, file);
        newXS("BackupPC::XS::PoolRefCnt::DeltaFileInit", XS_BackupPC__XS__PoolRefCnt_DeltaFileInit, file);
        newXS("BackupPC::XS::PoolRefCnt::DeltaFileFlush", XS_BackupPC__XS__PoolRefCnt_DeltaFileFlush, file);
        newXS("BackupPC::XS::PoolRefCnt::DeltaUpdate", XS_BackupPC__XS__PoolRefCnt_DeltaUpdate, file);
        newXS("BackupPC::XS::PoolRefCnt::DeltaPrint", XS_BackupPC__XS__PoolRefCnt_DeltaPrint, file);
        newXS("BackupPC::XS::PoolWrite::new", XS_BackupPC__XS__PoolWrite_new, file);
        newXS("BackupPC::XS::PoolWrite::DESTROY", XS_BackupPC__XS__PoolWrite_DESTROY, file);
        newXS("BackupPC::XS::PoolWrite::close", XS_BackupPC__XS__PoolWrite_close, file);
        newXS("BackupPC::XS::PoolWrite::write", XS_BackupPC__XS__PoolWrite_write, file);
        newXS("BackupPC::XS::PoolWrite::addToPool", XS_BackupPC__XS__PoolWrite_addToPool, file);
        newXS("BackupPC::XS::Attrib::new", XS_BackupPC__XS__Attrib_new, file);
        newXS("BackupPC::XS::Attrib::DESTROY", XS_BackupPC__XS__Attrib_DESTROY, file);
        newXS("BackupPC::XS::Attrib::get", XS_BackupPC__XS__Attrib_get, file);
        newXS("BackupPC::XS::Attrib::set", XS_BackupPC__XS__Attrib_set, file);
        newXS("BackupPC::XS::Attrib::digest", XS_BackupPC__XS__Attrib_digest, file);
        newXS("BackupPC::XS::Attrib::errStr", XS_BackupPC__XS__Attrib_errStr, file);
        newXS("BackupPC::XS::Attrib::count", XS_BackupPC__XS__Attrib_count, file);
        newXS("BackupPC::XS::Attrib::delete", XS_BackupPC__XS__Attrib_delete, file);
        newXS("BackupPC::XS::Attrib::read", XS_BackupPC__XS__Attrib_read, file);
        newXS("BackupPC::XS::Attrib::write", XS_BackupPC__XS__Attrib_write, file);
        newXS("BackupPC::XS::Attrib::fileType2Text", XS_BackupPC__XS__Attrib_fileType2Text, file);
        newXS("BackupPC::XS::AttribCache::new", XS_BackupPC__XS__AttribCache_new, file);
        newXS("BackupPC::XS::AttribCache::DESTROY", XS_BackupPC__XS__AttribCache_DESTROY, file);
        newXS("BackupPC::XS::AttribCache::get", XS_BackupPC__XS__AttribCache_get, file);
        newXS("BackupPC::XS::AttribCache::set", XS_BackupPC__XS__AttribCache_set, file);
        newXS("BackupPC::XS::AttribCache::delete", XS_BackupPC__XS__AttribCache_delete, file);
        newXS("BackupPC::XS::AttribCache::getInode", XS_BackupPC__XS__AttribCache_getInode, file);
        newXS("BackupPC::XS::AttribCache::setInode", XS_BackupPC__XS__AttribCache_setInode, file);
        newXS("BackupPC::XS::AttribCache::deleteInode", XS_BackupPC__XS__AttribCache_deleteInode, file);
        newXS("BackupPC::XS::AttribCache::count", XS_BackupPC__XS__AttribCache_count, file);
        newXS("BackupPC::XS::AttribCache::getAll", XS_BackupPC__XS__AttribCache_getAll, file);
        newXS("BackupPC::XS::AttribCache::flush", XS_BackupPC__XS__AttribCache_flush, file);
        newXS("BackupPC::XS::AttribCache::getFullMangledPath", XS_BackupPC__XS__AttribCache_getFullMangledPath, file);
        newXS("BackupPC::XS::DirOps::path_create", XS_BackupPC__XS__DirOps_path_create, file);
        newXS("BackupPC::XS::DirOps::path_remove", XS_BackupPC__XS__DirOps_path_remove, file);
        newXS("BackupPC::XS::DirOps::refCountAll", XS_BackupPC__XS__DirOps_refCountAll, file);
        newXS("BackupPC::XS::DirOps::lockRangeFd", XS_BackupPC__XS__DirOps_lockRangeFd, file);
        newXS("BackupPC::XS::DirOps::unlockRangeFd", XS_BackupPC__XS__DirOps_unlockRangeFd, file);
        newXS("BackupPC::XS::DirOps::lockRangeFile", XS_BackupPC__XS__DirOps_lockRangeFile, file);
        newXS("BackupPC::XS::DirOps::unlockRangeFile", XS_BackupPC__XS__DirOps_unlockRangeFile, file);
        newXS("BackupPC::XS::Lib::ConfInit", XS_BackupPC__XS__Lib_ConfInit, file);
        newXS("BackupPC::XS::Lib::logMsgGet", XS_BackupPC__XS__Lib_logMsgGet, file);
        newXS("BackupPC::XS::Lib::logErrorCntGet", XS_BackupPC__XS__Lib_logErrorCntGet, file);
        newXS("BackupPC::XS::Lib::logLevelSet", XS_BackupPC__XS__Lib_logLevelSet, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

